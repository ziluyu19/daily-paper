**编写计算**

首先用一种有**一些限制的**编程语言来表达我们的计算：我们只能使用变量赋值，然后使用加法和乘法运算符。变量是不可变的，我们不能使用无界循环。该语言**只能处理以 p 为模的整数**，其中 p 是一个大数，例如：0, 1, 2, …, 21888242871839275222246405745257275088696311157297823662689037894645226208583

只能使用固定大小的变量，没有无限循环，只有求和和乘法，确定的计算步骤数，...

可以使用**二进制变量***k、v、r、z*来**表达条件和比较，**就像我们在数字电子学中处理信号一样。通过使用这个技巧，我们可以将变量的条件、比较等映射到它们的**位**表示的和和乘法
![image](https://github.com/user-attachments/assets/8566cf53-bd85-4195-bda5-af2d820d31f8)



**circom 中的保留关键字：**
信号： 声明一个新信号。
input：声明信号为输入信号。
output：输出： 声明信号为输出信号
public：公用： 将 sigrsval 声明为 public。
template：模板： 定义一个新电路。
cormponent： 实例化模板。
var： 声明一个新的整数变量。
function： 定义一个新函数。
return：返回： 从函数中返回。
if:根据条件表达式的结果进行分支。
else： 如果控制流构造的回退
for： 根据表达式的结果有条件地循环。
while： 根据表达式的结果有条件地循环。
do： 根据表达式的结果有条件地循环。
log：打印评估结果。
assert：断言： 在构造时检查条件。
include：包含专用文件的代码。
parallel: 当各部分相互独立（输入不依赖于彼此的输出）时，可以使用 parallel标签并行计算这些部分。
pragma circom：检查编译器版本的指令。
pragma custom_templates：指示使用自定义模板的指令

##### Rank-1 约束系统 (R1CS)

通过采用一个电路并将其转换为一系列矩阵和向量，我们最终可以将其输入到任何支持 R1CS 的证明系统中以生成 zkSNARK。

为了获得 R1CS，我们必须将电路“扁平化”为一系列数学约束，其形式为`left * right = output` ，或等效的`left * right — output = 0` ，其中`left`是算术电路门的左线， `right`是右线， `output`是输出线。

![image](https://github.com/user-attachments/assets/d074ec3c-70c0-4834-8241-aaae923b9b87)

R1CS 表示之所以有效，是因为如果我们能够证明这组方程是正确的，那么我们就知道原始方程是正确的。证明者可以创建一个包含所有连线值的向量，称为*见证人*。*见证者*是算术电路的输入、输出和所有中间值的集合。默认情况下，见证向量还包含 w0 = 1 值

使用见证向量`w` ，我们可以创建一系列以下形式的方程

 `(w . left) * (w . right) — (w . output) = 0` 

`.`是点积运算（将两个相同大小的向量中的每个对应元素相乘，并将结果相加等于标量），它允许我们最终生成每个门的左、右和输出的向量。

##### Quadratic Arithmetic Program 二次算术程序 (QAP)

R1CS 过程完成后，输出是一系列向量，然后将其传递给二次算术程序 (QAP)，将输出向量转换为二次多项式系统。一旦数据采用这种多项式形式，就可以轻松地通过任意数量的交互式和非交互式证明系统进行检查
